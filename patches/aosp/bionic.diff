diff --git a/libc/Android.bp b/libc/Android.bp
index 08b3db3d9..71a4cd787 100644
--- a/libc/Android.bp
+++ b/libc/Android.bp
@@ -1665,7 +1665,7 @@ cc_library {
             },
 
             shared: {
-                whole_static_libs: [ "libgcc_stripped" ],
+                whole_static_libs: [ "libunwind_llvm" ],
             },
         },
         x86: {
diff --git a/libc/arch-arm64/bionic/setjmp.S b/libc/arch-arm64/bionic/setjmp.S
index a2b23702a..e4025a4be 100644
--- a/libc/arch-arm64/bionic/setjmp.S
+++ b/libc/arch-arm64/bionic/setjmp.S
@@ -297,3 +297,5 @@ ALIAS_SYMBOL(longjmp, siglongjmp)
 __BIONIC_WEAK_ASM_FOR_NATIVE_BRIDGE(longjmp)
 ALIAS_SYMBOL(_longjmp, siglongjmp)
 __BIONIC_WEAK_ASM_FOR_NATIVE_BRIDGE(_longjmp)
+
+#include "symauth.h"
diff --git a/libc/arch-arm64/bionic/syscall.S b/libc/arch-arm64/bionic/syscall.S
index 8389f9830..4fcb746d4 100644
--- a/libc/arch-arm64/bionic/syscall.S
+++ b/libc/arch-arm64/bionic/syscall.S
@@ -47,3 +47,5 @@ ENTRY(syscall)
 
     ret
 END(syscall)
+
+#include "symauth.h"
diff --git a/libc/arch-arm64/bionic/vfork.S b/libc/arch-arm64/bionic/vfork.S
index 5cfb8b0cc..d5f1ca060 100644
--- a/libc/arch-arm64/bionic/vfork.S
+++ b/libc/arch-arm64/bionic/vfork.S
@@ -85,3 +85,5 @@ __BIONIC_WEAK_ASM_FOR_NATIVE_BRIDGE(vfork)
 .L_exit:
     ret
 END(vfork)
+
+#include "symauth.h"
diff --git a/libc/arch-arm64/generic/bionic/__memcpy_chk.S b/libc/arch-arm64/generic/bionic/__memcpy_chk.S
index a6eeca477..53bf31526 100644
--- a/libc/arch-arm64/generic/bionic/__memcpy_chk.S
+++ b/libc/arch-arm64/generic/bionic/__memcpy_chk.S
@@ -43,3 +43,5 @@ ENTRY(__memcpy_chk)
 
   bl __memcpy_chk_fail
 END(__memcpy_chk)
+
+#include "symauth.h"
diff --git a/libc/arch-arm64/generic/bionic/memmove.S b/libc/arch-arm64/generic/bionic/memmove.S
index 335b7d6ce..75d40c774 100644
--- a/libc/arch-arm64/generic/bionic/memmove.S
+++ b/libc/arch-arm64/generic/bionic/memmove.S
@@ -153,3 +153,5 @@ END(memmove)
 
 ALIAS_SYMBOL(memcpy, memmove)
 #endif
+
+#include "symauth.h"
diff --git a/libc/arch-arm64/generic/bionic/memset.S b/libc/arch-arm64/generic/bionic/memset.S
index 12fc09db8..970a4f1a8 100644
--- a/libc/arch-arm64/generic/bionic/memset.S
+++ b/libc/arch-arm64/generic/bionic/memset.S
@@ -249,3 +249,5 @@ L(zva_other):
 	b	L(tail64)
 
 END(memset)
+
+#include "symauth.h"
diff --git a/libc/arch-common/bionic/crtbegin.c b/libc/arch-common/bionic/crtbegin.c
index b7043dcae..a67613d14 100644
--- a/libc/arch-common/bionic/crtbegin.c
+++ b/libc/arch-common/bionic/crtbegin.c
@@ -45,7 +45,7 @@ __used static void _start_main(void* raw_args) {
   __libc_init(raw_args, NULL, &main, &array);
 }
 
-#define PRE ".text; .global _start; .type _start,%function; _start:"
+#define PRE ".text; .global _start; .hidden _start; .type _start,%function; _start:"
 #define POST "; .size _start, .-_start"
 
 #if defined(__aarch64__)
diff --git a/libc/bionic/__libc_init_main_thread.cpp b/libc/bionic/__libc_init_main_thread.cpp
index 56a848888..188726554 100644
--- a/libc/bionic/__libc_init_main_thread.cpp
+++ b/libc/bionic/__libc_init_main_thread.cpp
@@ -82,6 +82,9 @@ extern "C" void __libc_init_main_thread_early(const KernelArgumentBlock& args,
   main_thread.tid = __getpid();
   main_thread.set_cached_pid(main_thread.tid);
   main_thread.stack_top = reinterpret_cast<uintptr_t>(args.argv);
+
+#define PR_PAC_SET_ENABLED_KEYS 59
+  // prctl(PR_PAC_SET_ENABLED_KEYS, PR_PAC_APIBKEY, 0, 0, 0);
 }
 
 // This code is used both by each new pthread and the code that initializes the main thread.
diff --git a/libc/bionic/bionic_call_ifunc_resolver.cpp b/libc/bionic/bionic_call_ifunc_resolver.cpp
index 437de78ce..379ed20e2 100644
--- a/libc/bionic/bionic_call_ifunc_resolver.cpp
+++ b/libc/bionic/bionic_call_ifunc_resolver.cpp
@@ -47,7 +47,15 @@ ElfW(Addr) __bionic_call_ifunc_resolver(ElfW(Addr) resolver_addr) {
     arg._hwcap = getauxval(AT_HWCAP);
     arg._hwcap2 = getauxval(AT_HWCAP2);
   }
-  return reinterpret_cast<ifunc_resolver_t>(resolver_addr)(arg._hwcap | _IFUNC_ARG_HWCAP, &arg);
+  auto* resolver_fn = reinterpret_cast<ifunc_resolver_t>(resolver_addr);
+#ifdef ANDROID_EXPERIMENTAL_PAC
+  resolver_fn = __builtin_ptrauth_sign_unauthenticated(resolver_fn, 0, 0);
+#endif
+  ElfW(Addr) addr = resolver_fn(arg._hwcap | _IFUNC_ARG_HWCAP, &arg);
+#ifdef ANDROID_EXPERIMENTAL_PAC
+  addr = reinterpret_cast<ElfW(Addr)>(__builtin_ptrauth_strip(reinterpret_cast<void*>(addr), 0));
+#endif
+  return addr;
 #elif defined(__arm__)
   typedef ElfW(Addr) (*ifunc_resolver_t)(unsigned long);
   static unsigned long hwcap;
@@ -62,3 +70,28 @@ ElfW(Addr) __bionic_call_ifunc_resolver(ElfW(Addr) resolver_addr) {
   return reinterpret_cast<ifunc_resolver_t>(resolver_addr)();
 #endif
 }
+
+#ifdef ANDROID_EXPERIMENTAL_PAC
+ElfW(Addr) __bionic_pac_sign_ptr(ElfW(Addr) addr, ElfW(Addr)* place) {
+  uintptr_t data = *place;
+  uint64_t discriminator = data & 0xffff;
+  if (data & (1 << 16)) {
+    discriminator =
+        (discriminator << 48) | (reinterpret_cast<uintptr_t>(place) & ((1ULL << 48) - 1));
+  }
+  switch ((data >> 17) & 3) {
+    case 0:
+      return reinterpret_cast<uintptr_t>(
+          __builtin_ptrauth_sign_unauthenticated(reinterpret_cast<void*>(addr), 0, discriminator));
+    case 1:
+      return reinterpret_cast<uintptr_t>(
+          __builtin_ptrauth_sign_unauthenticated(reinterpret_cast<void*>(addr), 1, discriminator));
+    case 2:
+      return reinterpret_cast<uintptr_t>(
+          __builtin_ptrauth_sign_unauthenticated(reinterpret_cast<void*>(addr), 2, discriminator));
+    case 3:
+      return reinterpret_cast<uintptr_t>(
+          __builtin_ptrauth_sign_unauthenticated(reinterpret_cast<void*>(addr), 3, discriminator));
+  }
+}
+#endif
diff --git a/libc/bionic/libc_init_static.cpp b/libc/bionic/libc_init_static.cpp
index cf5423e00..3b65ae876 100644
--- a/libc/bionic/libc_init_static.cpp
+++ b/libc/bionic/libc_init_static.cpp
@@ -63,7 +63,11 @@ extern "C" int __cxa_atexit(void (*)(void *), void *, void *);
 static void call_array(void(**list)()) {
   // First element is -1, list is null-terminated
   while (*++list) {
-    (*list)();
+    void (*fptr)() = *list;
+#ifdef ANDROID_EXPERIMENTAL_PAC
+    fptr = __builtin_ptrauth_sign_unauthenticated(fptr, 0, 0);
+#endif
+    fptr();
   }
 }
 
@@ -85,6 +89,13 @@ static void call_ifunc_resolvers() {
   for (ElfW(Rela) *r = __rela_iplt_start; r != __rela_iplt_end; ++r) {
     ElfW(Addr)* offset = reinterpret_cast<ElfW(Addr)*>(r->r_offset);
     ElfW(Addr) resolver = r->r_addend;
+#if defined(ANDROID_EXPERIMENTAL_PAC)
+#define R_AARCH64_AUTH_RELATIVE 0x4ff
+    if (ELF64_R_TYPE(r->r_info) == R_AARCH64_AUTH_RELATIVE) {
+      *offset = __bionic_pac_sign_ptr(resolver, offset);
+      continue;
+    }
+#endif
     *offset = __bionic_call_ifunc_resolver(resolver);
   }
 }
@@ -173,10 +184,10 @@ __noreturn static void __real_libc_init(void *raw_args,
   __libc_init_AT_SECURE(args.envp);
   layout_static_tls(args);
   __libc_init_main_thread_final();
+  call_ifunc_resolvers();
   __libc_init_common();
   __libc_init_fork_handler();
 
-  call_ifunc_resolvers();
   apply_gnu_relro();
 
   // Several Linux ABIs don't pass the onexit pointer, and the ones that
diff --git a/libc/bionic/vdso.cpp b/libc/bionic/vdso.cpp
index dbca9c013..619cd7a14 100644
--- a/libc/bionic/vdso.cpp
+++ b/libc/bionic/vdso.cpp
@@ -37,6 +37,9 @@ int clock_gettime(int clock_id, timespec* tp) {
   auto vdso_clock_gettime = reinterpret_cast<decltype(&clock_gettime)>(
     __libc_globals->vdso[VDSO_CLOCK_GETTIME].fn);
   if (__predict_true(vdso_clock_gettime)) {
+#ifdef ANDROID_EXPERIMENTAL_PAC
+    vdso_clock_gettime = __builtin_ptrauth_sign_unauthenticated(vdso_clock_gettime, 0, 0);
+#endif
     return vdso_return(vdso_clock_gettime(clock_id, tp));
   }
   return __clock_gettime(clock_id, tp);
@@ -46,6 +49,9 @@ int clock_getres(int clock_id, timespec* tp) {
   auto vdso_clock_getres = reinterpret_cast<decltype(&clock_getres)>(
     __libc_globals->vdso[VDSO_CLOCK_GETRES].fn);
   if (__predict_true(vdso_clock_getres)) {
+#ifdef ANDROID_EXPERIMENTAL_PAC
+    vdso_clock_getres = __builtin_ptrauth_sign_unauthenticated(vdso_clock_getres, 0, 0);
+#endif
     return vdso_return(vdso_clock_getres(clock_id, tp));
   }
   return __clock_getres(clock_id, tp);
@@ -55,6 +61,9 @@ int gettimeofday(timeval* tv, struct timezone* tz) {
   auto vdso_gettimeofday = reinterpret_cast<decltype(&gettimeofday)>(
     __libc_globals->vdso[VDSO_GETTIMEOFDAY].fn);
   if (__predict_true(vdso_gettimeofday)) {
+#ifdef ANDROID_EXPERIMENTAL_PAC
+    vdso_gettimeofday = __builtin_ptrauth_sign_unauthenticated(vdso_gettimeofday, 0, 0);
+#endif
     return vdso_return(vdso_gettimeofday(tv, tz));
   }
   return __gettimeofday(tv, tz);
@@ -63,6 +72,9 @@ int gettimeofday(timeval* tv, struct timezone* tz) {
 time_t time(time_t* t) {
   auto vdso_time = reinterpret_cast<decltype(&time)>(__libc_globals->vdso[VDSO_TIME].fn);
   if (__predict_true(vdso_time)) {
+#ifdef ANDROID_EXPERIMENTAL_PAC
+    vdso_time = __builtin_ptrauth_sign_unauthenticated(vdso_time, 0, 0);
+#endif
     return vdso_time(t);
   }
 
diff --git a/libc/private/NetdClientDispatch.h b/libc/private/NetdClientDispatch.h
index 7ebbe0c02..0bb229ad0 100644
--- a/libc/private/NetdClientDispatch.h
+++ b/libc/private/NetdClientDispatch.h
@@ -29,7 +29,7 @@ struct NetdClientDispatch {
     int (*sendto)(int, const void*, size_t, int, const struct sockaddr*, socklen_t);
     int (*socket)(int, int, int);
     unsigned (*netIdForResolv)(unsigned);
-    int (*dnsOpenProxy)();
+    int (*dnsOpenProxy)(void);
 };
 
 extern __LIBC_HIDDEN__ struct NetdClientDispatch __netdClientDispatch;
diff --git a/libc/private/bionic_asm_arm64.h b/libc/private/bionic_asm_arm64.h
index 463ca312a..0cbbdfdcf 100644
--- a/libc/private/bionic_asm_arm64.h
+++ b/libc/private/bionic_asm_arm64.h
@@ -41,3 +41,9 @@
 
 #undef __bionic_asm_function_type
 #define __bionic_asm_function_type %function
+
+/*
+#ifdef ANDROID_EXPERIMENTAL_PAC
+#define __bionic_asm_custom_end(f) .auth f, 0x80000000
+#endif
+*/
diff --git a/libc/private/bionic_call_ifunc_resolver.h b/libc/private/bionic_call_ifunc_resolver.h
index e0ea35bba..b92de0620 100644
--- a/libc/private/bionic_call_ifunc_resolver.h
+++ b/libc/private/bionic_call_ifunc_resolver.h
@@ -32,3 +32,4 @@
 #include <sys/cdefs.h>
 
 __LIBC_HIDDEN__ ElfW(Addr) __bionic_call_ifunc_resolver(ElfW(Addr) resolver_addr);
+__LIBC_HIDDEN__ ElfW(Addr) __bionic_pac_sign_ptr(ElfW(Addr) addr, ElfW(Addr)* place);
diff --git a/libc/tools/gensyscalls.py b/libc/tools/gensyscalls.py
index 0271a04c5..c60383df7 100755
--- a/libc/tools/gensyscalls.py
+++ b/libc/tools/gensyscalls.py
@@ -458,6 +458,10 @@ def main(arch, syscall_file):
     for syscall in parser.syscalls:
         if syscall.has_key("asm-%s" % arch):
             print(syscall["asm-%s" % arch])
+    if arch == "arm64":
+      print("""
+#include "symauth.h"
+""")
 
 
 if __name__ == "__main__":
diff --git a/libm/arm64/lrint.S b/libm/arm64/lrint.S
index 5f95ae817..4c37cae01 100644
--- a/libm/arm64/lrint.S
+++ b/libm/arm64/lrint.S
@@ -32,3 +32,5 @@ END(lrintf)
 ALIAS_SYMBOL(llrint, lrint);
 
 ALIAS_SYMBOL(llrintf, lrintf);
+
+#include "symauth.h"
diff --git a/libm/arm64/sqrt.S b/libm/arm64/sqrt.S
index 3a58ef364..46a9fb78d 100644
--- a/libm/arm64/sqrt.S
+++ b/libm/arm64/sqrt.S
@@ -25,3 +25,5 @@ ENTRY(sqrtf)
   fsqrt s0, s0
   ret
 END(sqrtf)
+
+#include "symauth.h"
diff --git a/linker/Android.bp b/linker/Android.bp
index 08b2c7b07..a718ff571 100644
--- a/linker/Android.bp
+++ b/linker/Android.bp
@@ -231,7 +231,7 @@ cc_defaults {
         },
         arm64: {
             srcs: [":linker_sources_arm64"],
-            static_libs: ["libgcc_stripped"],
+            static_libs: ["libunwind_llvm"],
         },
         x86: {
             srcs: [":linker_sources_x86"],
diff --git a/linker/linker.cpp b/linker/linker.cpp
index edf0329c9..ef823009f 100644
--- a/linker/linker.cpp
+++ b/linker/linker.cpp
@@ -2287,6 +2287,14 @@ bool do_dlsym(void* handle,
       } else {
         *symbol = reinterpret_cast<void*>(found->resolve_symbol_address(sym));
       }
+#ifdef ANDROID_EXPERIMENTAL_PAC
+      if (found->aarch64_auth_) {
+        uint32_t auth = found->aarch64_auth_[sym - found->symtab_];
+        if (auth & 0x80000000) {
+          *symbol = __builtin_ptrauth_sign_unauthenticated(*symbol, 0, auth & 0xffff);
+        }
+      }
+#endif
       failure_guard.Disable();
       LD_LOG(kLogDlsym,
              "... dlsym successful: sym_name=\"%s\", sym_ver=\"%s\", found in=\"%s\", address=%p",
@@ -2859,6 +2867,13 @@ bool soinfo::prelink_image() {
         symtab_ = reinterpret_cast<ElfW(Sym)*>(load_bias + d->d_un.d_ptr);
         break;
 
+#if defined(__aarch64__)
+#define DT_AARCH64_AUTH 0x7fffffff
+      case DT_AARCH64_AUTH:
+        aarch64_auth_ = reinterpret_cast<uint32_t*>(load_bias + d->d_un.d_ptr);
+        break;
+#endif
+
       case DT_SYMENT:
         if (d->d_un.d_val != sizeof(ElfW(Sym))) {
           DL_ERR("invalid DT_SYMENT: %zd in \"%s\"",
diff --git a/linker/linker_cfi.cpp b/linker/linker_cfi.cpp
index 5995013b4..45538fec6 100644
--- a/linker/linker_cfi.cpp
+++ b/linker/linker_cfi.cpp
@@ -199,9 +199,13 @@ bool CFIShadowWriter::NotifyLibDl(soinfo* solist, uintptr_t p) {
     return false;
   }
 
-  uintptr_t cfi_init = soinfo_find_symbol(libdl, "__cfi_init");
+  auto cfi_init =
+      reinterpret_cast<uintptr_t* (*)(uintptr_t)>(soinfo_find_symbol(libdl, "__cfi_init"));
   CHECK(cfi_init != 0);
-  shadow_start = reinterpret_cast<uintptr_t* (*)(uintptr_t)>(cfi_init)(p);
+#ifdef ANDROID_EXPERIMENTAL_PAC
+  cfi_init = __builtin_ptrauth_sign_unauthenticated(cfi_init, 0, 0);
+#endif
+  shadow_start = cfi_init(p);
   CHECK(shadow_start != nullptr);
   CHECK(*shadow_start == p);
   mprotect(shadow_start, PAGE_SIZE, PROT_READ);
diff --git a/linker/linker_main.cpp b/linker/linker_main.cpp
index 41bb4baee..30e788588 100644
--- a/linker/linker_main.cpp
+++ b/linker/linker_main.cpp
@@ -578,6 +578,12 @@ static void call_ifunc_resolvers(ElfW(Addr) load_bias) {
   for (ElfW(Rela) *r = __rela_iplt_start; r != __rela_iplt_end; ++r) {
     ElfW(Addr)* offset = reinterpret_cast<ElfW(Addr)*>(r->r_offset + load_bias);
     ElfW(Addr) resolver = r->r_addend + load_bias;
+#if defined(__aarch64__) && defined(ANDROID_EXPERIMENTAL_PAC)
+#define R_AARCH64_AUTH_RELATIVE 0x4ff
+    if (ELF64_R_TYPE(r->r_info) == R_AARCH64_AUTH_RELATIVE) {
+      continue;
+    }
+#endif
     *offset = __bionic_call_ifunc_resolver(resolver);
   }
 }
@@ -656,6 +662,15 @@ extern "C" ElfW(Addr) __linker_init(void* raw_args) {
   const ElfW(Addr) load_bias = get_elf_exec_load_bias(elf_hdr);
   call_ifunc_resolvers(load_bias);
 
+#ifdef ANDROID_EXPERIMENTAL_PAC
+  if (strcmp(args.argv[0], "/system/bin/app_process64") == 0) {
+    if (fork() == 0) {
+#define PR_PAC_SET_ENABLED_KEYS 59
+      prctl(PR_PAC_SET_ENABLED_KEYS, PR_PAC_APIBKEY, 0, 0, 0);
+    }
+  }
+#endif
+
   soinfo tmp_linker_so(nullptr, nullptr, nullptr, 0, 0);
 
   tmp_linker_so.base = linker_addr;
@@ -702,7 +717,11 @@ __linker_init_post_relocation(KernelArgumentBlock& args, soinfo& tmp_linker_so)
   // as PT_INTERP, AT_ENTRY will refer to the loaded executable rather than the
   // linker's _start.
   const char* exe_to_load = nullptr;
-  if (getauxval(AT_ENTRY) == reinterpret_cast<uintptr_t>(&_start)) {
+  void (*start_ptr)() = _start;
+#ifdef ANDROID_EXPERIMENTAL_PAC
+  start_ptr = __builtin_ptrauth_strip(start_ptr, 0);
+#endif
+  if (getauxval(AT_ENTRY) == reinterpret_cast<uintptr_t>(start_ptr)) {
     if (args.argc == 3 && !strcmp(args.argv[1], "--list")) {
       // We're being asked to behave like ldd(1).
       g_is_ldd = true;
diff --git a/linker/linker_relocate.cpp b/linker/linker_relocate.cpp
index 72be5f74c..f16622aac 100644
--- a/linker/linker_relocate.cpp
+++ b/linker/linker_relocate.cpp
@@ -42,6 +42,7 @@
 #include "linker_reloc_iterators.h"
 #include "linker_sleb128.h"
 #include "linker_soinfo.h"
+#include "private/bionic_call_ifunc_resolver.h"
 #include "private/bionic_globals.h"
 
 static bool is_tls_reloc(ElfW(Word) type) {
@@ -464,6 +465,22 @@ static bool process_relocation_impl(Relocator& relocator, const rel_t& reloc) {
         }
       }
       break;
+#define R_AARCH64_AUTH64 0x1ff
+#define R_AARCH64_AUTH_RELATIVE 0x4ff
+#if defined(ANDROID_EXPERIMENTAL_PAC)
+    case R_AARCH64_AUTH64: {
+      const ElfW(Addr) result =
+          __bionic_pac_sign_ptr(sym_addr + get_addend_rel(), static_cast<ElfW(Addr)*>(rel_target));
+      *static_cast<ElfW(Addr)*>(rel_target) = result;
+      break;
+    }
+    case R_AARCH64_AUTH_RELATIVE: {
+      const ElfW(Addr) result = __bionic_pac_sign_ptr(relocator.si->load_bias + get_addend_rel(),
+                                                      static_cast<ElfW(Addr)*>(rel_target));
+      *static_cast<ElfW(Addr)*>(rel_target) = result;
+      break;
+    }
+#endif  // defined(ANDROID_EXPERIMENTAL_PAC)
 #endif  // defined(__aarch64__)
 
 #if defined(__x86_64__)
diff --git a/linker/linker_soinfo.cpp b/linker/linker_soinfo.cpp
index 4f67003b8..8ac5136f5 100644
--- a/linker/linker_soinfo.cpp
+++ b/linker/linker_soinfo.cpp
@@ -468,6 +468,9 @@ static void call_function(const char* function_name __unused,
   }
 
   TRACE("[ Calling c-tor %s @ %p for '%s' ]", function_name, function, realpath);
+#ifdef ANDROID_EXPERIMENTAL_PAC
+  function = __builtin_ptrauth_sign_unauthenticated(function, 0, 0);
+#endif
   function(g_argc, g_argv, g_envp);
   TRACE("[ Done calling c-tor %s @ %p for '%s' ]", function_name, function, realpath);
 }
@@ -480,6 +483,9 @@ static void call_function(const char* function_name __unused,
   }
 
   TRACE("[ Calling d-tor %s @ %p for '%s' ]", function_name, function, realpath);
+#ifdef ANDROID_EXPERIMENTAL_PAC
+  function = __builtin_ptrauth_sign_unauthenticated(function, 0, 0);
+#endif
   function();
   TRACE("[ Done calling d-tor %s @ %p for '%s' ]", function_name, function, realpath);
 }
diff --git a/linker/linker_soinfo.h b/linker/linker_soinfo.h
index e1a3c303d..53296932b 100644
--- a/linker/linker_soinfo.h
+++ b/linker/linker_soinfo.h
@@ -180,11 +180,13 @@ struct soinfo {
 #endif
 
   soinfo* next;
- private:
   uint32_t flags_;
 
   const char* strtab_;
   ElfW(Sym)* symtab_;
+#if defined(__aarch64__)
+  uint32_t* aarch64_auth_;
+#endif
 
   size_t nbucket_;
   size_t nchain_;
